name: Sync to Public Repository

on:
  # Manual trigger
  workflow_dispatch:
    inputs:
      sync_type:
        description: 'Type of sync operation'
        required: false
        default: ''
        type: choice
        options:
          - ' ' # Empty for auto-detection
          - feature
          - bugfix
          - docs
          - release
          - hotfix
      message:
        description: '' # Empty for auto-detection
        required: false
        default: '' # Empty for auto-detection
      version:
        description: '' # Empty for auto-detection
        required: false
        type: string
      dry_run:
        description: 'Test mode (no actual push to public repo)'
        required: false
        default: false
        type: boolean
      publish_npm:
        description: 'Publish to NPM (even if no version change detected)'
        required: false
        default: false
        type: boolean
  
  # Auto-trigger on new releases
  release:
    types: [published]
    
  # Auto-trigger weekly for regular syncs
  schedule:
    - cron: '0 0 * * 0'  # Weekly on Sunday at midnight UTC

jobs:
  sync:
    runs-on: ubuntu-latest
    # Only run on the main private repo, and check if there are any changes to sync for scheduled runs
    if: |
      github.repository == 'TuckerTucker/tkr-kanban' &&
      (github.event_name != 'schedule' || !contains(github.event.head_commit.message, 'Synced at:'))
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Determine sync details
        id: sync-details
        run: |
          # Find last sync by looking at commits with "Synced at:" message
          LAST_SYNC_COMMIT=$(git log --grep="Synced at:" -n 1 --pretty=format:"%H" || echo "")
          
          if [ -z "$LAST_SYNC_COMMIT" ]; then
            # If never synced, use all commits
            echo "First sync - using all commits"
            COMMIT_RANGE="HEAD"
          else
            echo "Last sync found at commit: $LAST_SYNC_COMMIT"
            COMMIT_RANGE="$LAST_SYNC_COMMIT..HEAD"
          fi
          
          # Auto-detect version from tags
          LATEST_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ ! -z "$LATEST_VERSION" ]; then
            # Check if this version was already synced
            LAST_SYNCED_VERSION=$(git log --grep="Synced at:" -n 1 --pretty=format:"%s" | grep -o "v[0-9]*\.[0-9]*\.[0-9]*" || echo "")
            
            if [ "$LATEST_VERSION" != "$LAST_SYNCED_VERSION" ]; then
              AUTO_VERSION="${LATEST_VERSION#v}"
              echo "Latest version: $AUTO_VERSION (not yet synced)"
            else
              echo "Latest version $LATEST_VERSION already synced"
              AUTO_VERSION=""
            fi
          else
            AUTO_VERSION=""
          fi
          
          # Determine sync type by analyzing commits
          FEATURE_COUNT=$(git log $COMMIT_RANGE --pretty=format:"%s" | grep -i "feat\|feature\|add" | wc -l)
          FIX_COUNT=$(git log $COMMIT_RANGE --pretty=format:"%s" | grep -i "fix\|bug\|issue" | wc -l)
          DOCS_COUNT=$(git log $COMMIT_RANGE --pretty=format:"%s" | grep -i "doc\|readme\|comment" | wc -l)
          
          if [ ! -z "$AUTO_VERSION" ]; then
            AUTO_TYPE="release"
          elif [ $FEATURE_COUNT -gt $FIX_COUNT ] && [ $FEATURE_COUNT -gt $DOCS_COUNT ]; then
            AUTO_TYPE="feature"
          elif [ $FIX_COUNT -gt $FEATURE_COUNT ] && [ $FIX_COUNT -gt $DOCS_COUNT ]; then
            AUTO_TYPE="bugfix"
          elif [ $DOCS_COUNT -gt $FEATURE_COUNT ] && [ $DOCS_COUNT -gt $FIX_COUNT ]; then
            AUTO_TYPE="docs"
          else
            AUTO_TYPE="feature"  # Default
          fi
          
          # Generate message from commits
          AUTO_MESSAGE=$(git log $COMMIT_RANGE --pretty=format:"- %s" | head -5 | sed '/^$/d' | sed 's/^/ /' | sed ':a;N;$!ba;s/\n/\\n/g')
          
          # Use manual inputs if provided, otherwise use auto-detected values
          SYNC_TYPE="${{ github.event.inputs.sync_type }}"
          SYNC_MESSAGE="${{ github.event.inputs.message }}"
          SYNC_VERSION="${{ github.event.inputs.version }}"
          
          if [ -z "$SYNC_TYPE" ]; then
            SYNC_TYPE="$AUTO_TYPE"
          fi
          
          if [ -z "$SYNC_MESSAGE" ]; then
            if [ -z "$AUTO_MESSAGE" ]; then
              SYNC_MESSAGE="Sync recent changes from private repo to public repo"
            else
              SYNC_MESSAGE="$AUTO_MESSAGE"
            fi
          fi
          
          if [ -z "$SYNC_VERSION" ] && [ ! -z "$AUTO_VERSION" ]; then
            SYNC_VERSION="$AUTO_VERSION"
          fi
          
          echo "type=$SYNC_TYPE" >> $GITHUB_OUTPUT
          echo "message=$SYNC_MESSAGE" >> $GITHUB_OUTPUT
          echo "version=$SYNC_VERSION" >> $GITHUB_OUTPUT
          
          echo "Determined sync type: $SYNC_TYPE"
          echo "Determined message: $SYNC_MESSAGE"
          echo "Determined version: $SYNC_VERSION"
      
      - name: Configure Git
        run: |
          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"
      
      - name: Create or checkout public-content branch
        run: |
          git fetch origin public-content || true
          if git rev-parse --verify origin/public-content >/dev/null 2>&1; then
            git checkout public-content
            git pull origin public-content
          else
            git checkout -b public-content
          fi
      
      - name: Clear branch for clean sync
        run: |
          git rm -rf .
          mkdir -p .github/workflows
          git commit -m "Clear branch for public release sync" || true
      
      - name: Copy core files
        run: |
          # Copy application code
          git checkout main -- app/
          git checkout main -- server/
          git checkout main -- package.json
          git checkout main -- start_*
          
          # Copy core workflows
          git checkout main -- .github/workflows/ci.yml
          git checkout main -- .github/workflows/release.yml
          
          # Copy documentation
          git checkout main -- README.md
          git checkout main -- README_MCP.md
          git checkout main -- README_CLI.md
          git checkout main -- CODE_OF_CONDUCT.md
          git checkout main -- CONTRIBUTING.md
          git checkout main -- LICENSE.md
          
          # Copy configuration templates
          git checkout main -- config/
          
          # Copy examples, tests, docs directories
          git checkout main -- tests/
          git checkout main -- docs/
          git checkout main -- releases/
          git checkout main -- tutorials/
          
          # Create placeholder directories
          mkdir -p boards webhooks
          touch boards/.gitkeep webhooks/.gitkeep
          
          # Copy example board if it exists
          git checkout main -- boards/_kanban_example.json || true
          
          # Add .gitignore
          cat > .gitignore << EOF
          # Node modules
          node_modules/
          
          # Personal boards
          boards/*.json
          !boards/_kanban_example.json
          
          # Webhook configurations
          webhooks/*.json
          
          # Environment variables
          .env
          .env.*
          
          # IDE files
          .vscode/
          .idea/
          *.sublime-*
          
          # OS files
          .DS_Store
          Thumbs.db
          
          # Logs
          logs/
          *.log
          npm-debug.log*
          
          # Coverage
          coverage/
          
          # Build artifacts
          dist/
          build/
          EOF
          
          git add .
          
          # Construct a detailed commit message with sync type and optional version
          COMMIT_MSG="${{ steps.sync-details.outputs.type }}: ${{ steps.sync-details.outputs.message }}"
          
          # Add version if provided
          if [ ! -z "${{ steps.sync-details.outputs.version }}" ]; then
            COMMIT_MSG="$COMMIT_MSG (v${{ steps.sync-details.outputs.version }})"
          fi
          
          # Add sync source information
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            TRIGGER="manual sync by @${{ github.actor }}"
          elif [ "${{ github.event_name }}" == "release" ]; then
            TRIGGER="release ${{ github.event.release.tag_name }}"
          elif [ "${{ github.event_name }}" == "schedule" ]; then
            TRIGGER="weekly scheduled sync"
          else
            TRIGGER="automated sync"
          fi
          
          # Add timestamp and trigger info for tracking with proper newlines
          COMMIT_MSG=$(printf "%s\n\nSynced at: %s\nTriggered by: %s" "$COMMIT_MSG" "$(date -u '+%Y-%m-%d %H:%M:%S UTC')" "$TRIGGER")
          
          git commit -m "$COMMIT_MSG" || true
      
      - name: Set up SSH Deploy Key
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.DEPLOY_KEY }}

      - name: Add public remote with SSH
        run: |
          echo "Setting up remote with SSH key..."
          git remote -v
          git remote remove public || true
          
          # Using SSH for authentication
          echo "Adding remote with SSH authentication..."
          git remote add public git@github.com:TuckerTucker/TaskBoardAI.git
          
          # Verify remote
          git remote -v
          
          # Setup known hosts to avoid prompts
          mkdir -p ~/.ssh
          ssh-keyscan github.com >> ~/.ssh/known_hosts
      
      - name: Push changes
        run: |
          echo "Preparing to push changes to public repository..."
          echo ">> Sync type: ${{ steps.sync-details.outputs.type }}"
          echo ">> Sync message: ${{ steps.sync-details.outputs.message }}"
          if [ ! -z "${{ steps.sync-details.outputs.version }}" ]; then
            echo ">> Version: ${{ steps.sync-details.outputs.version }}"
          fi
          
          # Check for dry run mode
          if [ "${{ github.event.inputs.dry_run }}" == "true" ]; then
            echo "ðŸ” DRY RUN MODE ENABLED - No changes will be pushed"
            echo "âœ“ Sync validation completed successfully"
            echo "ðŸ“„ Content that would be pushed:"
            git ls-files | sort
            echo "ðŸ“„ Total files: $(git ls-files | wc -l)"
            echo "ðŸ’¡ To execute the actual push, run the workflow without the dry_run option"
            exit 0
          fi
          
          # Push local public-content branch to public/main
          echo "ðŸ”„ Pushing to public repository..."
          git push -f public public-content:main
          
          echo "âœ“ Push completed successfully"
          echo "âœ“ Changes are now live on the public repository at:"
          echo "  https://github.com/TuckerTucker/TaskBoardAI"
          
          # Create tag if this is a version release and auto-triggered
          if [ ! -z "${{ steps.sync-details.outputs.version }}" ] && [ "${{ github.event_name }}" != "workflow_dispatch" ]; then
            VERSION_TAG="v${{ steps.sync-details.outputs.version }}"
            echo "Creating version tag $VERSION_TAG in public repository..."
            
            git tag -f "public-$VERSION_TAG" || true
            git push -f public "public-$VERSION_TAG" || true
            
            echo "âœ“ Version tag created in public repository"
          fi
      
      - name: Set up Node.js for NPM publishing
        if: steps.sync-details.outputs.version != '' || github.event.inputs.publish_npm == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          registry-url: 'https://registry.npmjs.org'
          cache: 'npm'

      - name: Install dependencies
        if: steps.sync-details.outputs.version != '' || github.event.inputs.publish_npm == 'true'
        run: npm ci

      - name: Publish to NPM
        if: steps.sync-details.outputs.version != '' || github.event.inputs.publish_npm == 'true'
        run: |
          echo "Publishing package to NPM registry..."
          VERSION="${{ steps.sync-details.outputs.version }}"
          
          # Extract version from public package.json
          PACKAGE_VERSION=$(grep -o '"version": "[^"]*"' package.json | cut -d'"' -f4)
          
          echo "Package.json version: $PACKAGE_VERSION"
          
          # Check if we need to update the version
          if [ ! -z "$VERSION" ] && [ "$PACKAGE_VERSION" != "$VERSION" ]; then
            echo "âš ï¸ Warning: Package version ($PACKAGE_VERSION) does not match expected version ($VERSION)"
            echo "Updating package.json to match expected version..."
            # Use npm version to update the version (without creating a git tag)
            npm version $VERSION --no-git-tag-version
            PACKAGE_VERSION=$VERSION
          else
            echo "Using package.json version: $PACKAGE_VERSION"
          fi
          
          # Ensure the package has the publishConfig configuration
          if ! grep -q '"publishConfig"' package.json; then
            echo "Adding publishConfig to package.json..."
            # Using a temporary file since in-place editing is safer this way
            TMP_FILE=$(mktemp)
            sed -e '/"version": ".*"/a\
              "publishConfig": {\
                "access": "public"\
              },' package.json > "$TMP_FILE"
            mv "$TMP_FILE" package.json
          fi
          
          # Publish to NPM
          npm publish
          
          echo "âœ… Successfully published version v$PACKAGE_VERSION to NPM registry"
          echo "ðŸ“¦ Package link: https://www.npmjs.com/package/taskboardai/v/$PACKAGE_VERSION"
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}