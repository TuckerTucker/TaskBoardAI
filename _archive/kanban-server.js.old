const express = require('express');
const cors = require('cors');
const fs = require('fs').promises;
const path = require('path');

const app = express();
const PORT = process.env.PORT || 3001;

// Get board file from environment variable or use default
const boardFile = process.env.BOARD_FILE || 'kanban.json';

// Support absolute paths while maintaining backwards compatibility
const isAbsolutePath = path.isAbsolute(boardFile);
const BOARDS_DIR = path.join(__dirname, '../boards');

// Handle .json extension
const hasJsonExt = boardFile.toLowerCase().endsWith('.json');

// Set final data file path
let DATA_FILE;
if (process.env.BOARD_FILE) {
    // If BOARD_FILE is set in env, use it directly (just ensure .json extension)
    DATA_FILE = hasJsonExt ? boardFile : `${boardFile}.json`;
} else {
    // For default case, use boards directory
    const normalizedBoardFile = hasJsonExt ? boardFile : `${boardFile}.json`;
    DATA_FILE = path.join(BOARDS_DIR, normalizedBoardFile);
}

// Log the board file being used
console.log('Using board file:', DATA_FILE);

app.use(cors());
app.use(express.json());

// Serve static files from app directory
app.use(express.static(path.join(__dirname, '../app')));
app.use('/css', express.static(path.join(__dirname, '../css')));
app.use('/img', express.static(path.join(__dirname, '../img')));

// Ensure boards directory exists
async function ensureBoardsDir() {
    try {
        // If using absolute path, ensure its directory exists
        const dirToCreate = isAbsolutePath ? path.dirname(DATA_FILE) : BOARDS_DIR;
        await fs.mkdir(dirToCreate, { recursive: true });
    } catch (err) {
        if (err.code !== 'EEXIST') throw err;
    }
}

// Initialize data file with empty arrays if it doesn't exist
async function initDataFile() {
    try {
        await fs.access(DATA_FILE);
    } catch {
        const initialData = {
            projectName: "My Kanban Board",
            columns: []
        };
        await fs.writeFile(DATA_FILE, JSON.stringify(initialData, null, 2));
        console.log('Created new board file:', DATA_FILE);
    }
}

// Send current board file info to client
app.get('/api/boardinfo', (req, res) => {
    res.json({ 
        boardFile: boardFile,
        fullPath: DATA_FILE 
    });
});

// Get all kanban data
app.get('/api/kanban', async (req, res) => {
    try {
        const data = await fs.readFile(DATA_FILE, 'utf8');
        res.json(JSON.parse(data));
    } catch (error) {
        if (error.code === 'ENOENT') {
            // If file doesn't exist, return default structure
            const defaultData = {
                projectName: 'My Kanban Board',
                columns: []
            };
            await fs.writeFile(DATA_FILE, JSON.stringify(defaultData, null, 2));
            console.log('Created default board structure:', DATA_FILE);
            res.json(defaultData);
        } else {
            console.error('Error reading kanban data:', error);
            res.status(500).json({ error: 'Failed to read kanban data' });
        }
    }
});

// Validate item structure
function validateItem(item) {
    // Required fields (V1 compatibility)
    if (!item || typeof item !== 'object') return false;
    if (!item.id || typeof item.id !== 'string') return false;
    if (!item.title || typeof item.title !== 'string') return false;
    if (typeof item.collapsed !== 'boolean' && item.collapsed !== undefined) return false;

    // Content field (supports both content and description)
    if (item.content && typeof item.content !== 'string') return false;
    if (item.description && typeof item.description !== 'string') return false;

    // Optional V2.1 fields
    if (item.subtasks !== undefined) {
        if (!Array.isArray(item.subtasks)) return false;
        if (!item.subtasks.every(task => typeof task === 'string')) return false;
    }

    if (item.tags !== undefined) {
        if (!Array.isArray(item.tags)) return false;
        if (!item.tags.every(tag => typeof tag === 'string')) return false;
    }

    if (item.dependencies !== undefined) {
        if (!Array.isArray(item.dependencies)) return false;
        if (!item.dependencies.every(dep => typeof dep === 'string')) return false;
    }

    if (item.completed_at !== undefined) {
        const timestamp = new Date(item.completed_at);
        if (isNaN(timestamp.getTime())) return false;
    }

    return true;
}

// Validate column structure
function validateColumn(column) {
    if (!column || typeof column !== 'object') return false;
    if (!column.id || typeof column.id !== 'string') return false;
    if (!column.name || typeof column.name !== 'string') return false;
    if (!Array.isArray(column.items)) return false;
    return column.items.every(validateItem);
}

// Validate board data
function validateBoardData(data) {
    if (!data || typeof data !== 'object') return false;
    if (!data.projectName || typeof data.projectName !== 'string') return false;
    if (!Array.isArray(data.columns)) return false;

    // Optional V2.1 fields
    if (data.description !== undefined && typeof data.description !== 'string') return false;
    if (data.last_updated !== undefined) {
        const timestamp = new Date(data.last_updated);
        if (isNaN(timestamp.getTime())) return false;
    }

    return data.columns.every(validateColumn);
}

// Update kanban data
app.post('/api/kanban', async (req, res) => {
    const data = req.body;
    
    // Validate board data
    if (!validateBoardData(data)) {
        return res.status(400).json({ error: 'Invalid board data format' });
    }

    try {
        // Update last_updated timestamp
        data.last_updated = new Date().toISOString();

        // Add completion timestamps for items in Done column
        data.columns.forEach(column => {
            if (column.name.toLowerCase() === 'done') {
                column.items.forEach(item => {
                    if (!item.completed_at) {
                        item.completed_at = new Date().toISOString();
                    }
                });
            } else {
                // Remove completion timestamp if moved out of Done
                column.items.forEach(item => {
                    delete item.completed_at;
                });
            }
        });

        await fs.writeFile(DATA_FILE, JSON.stringify(data, null, 2));
        res.json({ success: true });
    } catch (error) {
        console.error('Error saving board data:', error);
        res.status(500).json({ error: 'Failed to save board data' });
    }
});

// Serve index.html for all other routes
app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, '../app/index.html'));
});

// Initialize server
async function init() {
    try {
        await ensureBoardsDir();
        await initDataFile();
        
        const server = app.listen(PORT, () => {
            console.log(`Server running at http://localhost:${PORT}`);
            console.log(`Using board file: ${DATA_FILE}`);
        });

        server.on('error', (error) => {
            console.error('Server error:', error);
            process.exit(1);
        });
    } catch (error) {
        console.error('Initialization error:', error);
        process.exit(1);
    }
}

init();
